为了降低理解难度，我们回到最开始的案例代码：

```typescript
const layer = document.querySelector("#layer");
const btn = document.querySelector("#btn");
const obj = {
  name: "张三",
  age: 18,
};

const buckets = new Set();

const handler = {
  get(target, key, receiver) {
    buckets.add(effect);
    const result = Reflect.get(target, key, receiver);
    return result;
  },
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    buckets.forEach((effect) => effect());
    return result;
  },
};

const proxy = new Proxy(obj, handler);

function effect() {
  layer.innerHTML = proxy.name;
}

effect(); 

btn.addEventListener("click", () => {
  proxy.name = "李四"; 
});
```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="layer"></div>
  <button id="btn">修改</button>
</body>
<script src="index.js"></script>
</html>
```

### 1、解决`effect`函数硬编码问题

现在这个样子相当于就硬编码了副作用函数`effect`，这个函数名我们当然不能直接就固定死，所以简单做一下处理

```typescript
// 用全局变量存储需要被收集的副作用函数
let activeEffect;

// effect函数现在的作用相当于是注册副作用函数
function effect(fn) {
  // 当调用effect函数时,将fn存储到activeEffect中
  activeEffect = fn;
  // 执行fn函数
  fn();
}
```

完整代码：

```typescript
const layer = document.querySelector("#layer");
const btn = document.querySelector("#btn");
const obj = {
  name: "张三",
  age: 18,
};

const buckets = new Set();

const handler = {
  get(target, key, receiver) {
    // 将activeEffect中存储的副作用函数收集到buckets中
    if (activeEffect) { 
      buckets.add(activeEffect);
    }
    const result = Reflect.get(target, key, receiver);
    return result;
  },
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    buckets.forEach(fn => fn());
    return result;
  },
};

const proxy = new Proxy(obj, handler);

// 用全局变量存储需要被收集的副作用函数
let activeEffect;

// effect函数现在的作用相当于是注册副作用函数
function effect(fn) {
  // 当调用effect函数时,将fn存储到activeEffect中
  activeEffect = fn;
  // 执行fn函数
  fn();
}

effect(function effectFn() {
  console.log("fn");

  layer.innerHTML = proxy.name;
}); 

btn.addEventListener("click", () => {
  proxy.name = "李四"; 
});

```

但是现在还是存在一个问题，当点击按钮再次执行修改时，由于我们修改了`proxy.name`属性，当然会触发依赖收集，从而重新触发函数`fn`执行。

但是，当我给proxy代理对象添加一个之前不存在的属性的时候，按照我们现在这里的简单写法，这里新加的属性都没有进行依赖收集，但是还是会触发`fn`函数，这就不是太合理了。

```typescript
btn.addEventListener("click", () => {
  // proxy.name = "李四"; 

  // 设置一个不存在的属性,还是会再次fn函数
  proxy.address = "北京"; 
});
```

导致这个问题的根本原因是，我们**没有在副作用函数与被操作的目标字段之间建立明确的关系**，只是代理对象发现有`set`函数触发了，就会到`buckets`中取出函数执行。

### 2、理解数据结构的设计

```typescript
effect(function effectFn() {
  layer.innerHTML = proxy.name;
}); 
```

这段代码代码中的存在着三个角色：

- 被操作(读取)的代理对象`proxy`
- 被操作读取的属性名`name`
- 使用effect函数注册的副作用函数`effectFn`

为了方便说明，我下面用`target`来代表代理对象，`key`表示被操作的属性名，`effectFn`表示被注册的副作用函数，那么着三个角色的关系应该是下面这个样子的：

![image-20240829165153834](./assets/image-20240829165153834.png)

但是，如果有两个副作用函数同时读取了同一个对象的属性值，类似于：

```typescript
effect(function effectFn1(){
  target.name
})
effect(function effectFn2(){
  target.name
})
```

那么它们的关系就如下：

![image-20240829165447822](./assets/image-20240829165447822.png)

但是如果一个副作用函数读取了同一个对象的两个不同的属性，比如：

```typescript
effect(function effectFn(){
  target.name1
  target.name2
})
```

那这个样子的关系就如下：

![image-20240829170906763](./assets/image-20240829170906763.png)

如果在不同的副作用函数中读取了两个不同对象的不同属性，类似于：

```typescript
effect(function effectFn1(){
  target1.name1
})
effect(function effectFn2(){
  target2.name2
})
```

那么关系如下：

![image-20240829171515429](./assets/image-20240829171515429.png)

根据上面的这些情况，我们可以建立出下面的数据结构关系：

![image-20240831110917239](./assets/image-20240831110917239.png)

根据这样的数据结构，我们可以将代码改成下面的样子

```typescript
const layer = document.querySelector("#layer");
const btn = document.querySelector("#btn");
const obj = {
  name: "张三",
  age: 18,
};

const buckets = new WeakMap();

const handler = {
  get(target, key, receiver) {
    const result = Reflect.get(target, key, receiver);
    // 没有activeEffect,直接返回
    if (!activeEffect) {
      return result;
    }
    // 1.根据target从buckets中获取depsMap,它是一个Map对象，保存类型是key---effects的键值对
    let depsMap = buckets.get(target);
    // 如果depsMap不存在,则创建一个新的Map对象
    if (!depsMap) {
      buckets.set(target, (depsMap = new Map()));
    }

    // 2.根据key从depsMap中获取effects,它是一个Set对象
    // 里面存储的是当前key对应的副作用函数
    let deps = depsMap.get(key);
    // 如果deps不存在,则创建一个新的Set对象
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // 3.将activeEffect存储到deps中
    deps.add(activeEffect);

    return result;
  },
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    // 根据target从buckets中获取depsMap
    const depsMap = buckets.get(target);
    // 如果depsMap不存在,则直接返回
    if (!depsMap) {
      return result;
    }
    // 根据key从depsMap中获取effects
    const deps = depsMap.get(key);
    // 如果deps不存在,则直接返回
    if (!deps) {
      return result;
    }
    // 执行effects中的副作用函数
    deps.forEach(fn => fn());
    return result;
  },
};

const proxy = new Proxy(obj, handler);

let activeEffect;

function effect(fn) {
  activeEffect = fn;
  fn();
}

effect(function effectFn() {
  console.log("fn");

  layer.innerHTML = proxy.name;
}); 

btn.addEventListener("click", () => {
  proxy.name = "李四"; // 触发更新

  // proxy.address = "北京"; 
});
```

> 至于最外层为什么要用`WeakMap`？原因很简单，如果`target`对象没有任何引用了，说明用户不再需要它了，这时垃圾回收器会完成回收任务。如果直接使用`Map`，那即使`target`在用户侧没有任何引用了，这个`target`也不会被回收，最终可能会导致内存溢出

### 3、封装逻辑

在读取属性值时，我们可以把副作用函数收集到buckets的这部分逻辑封装到track函数中，track函数的意义就表示追踪。同样，我们也可以把触发副作用函数重新执行的逻辑封装到trigger函数中。

```typescript
// 封装track和trigger函数
const layer = document.querySelector("#layer");
const btn = document.querySelector("#btn");
const obj = {
  name: "张三",
  age: 18,
};

const buckets = new WeakMap();

const handler = {
  get(target, key, receiver) {
    track(target, key);
    const result = Reflect.get(target, key, receiver);
    return result;
  },
  set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    trigger(target, key);
    return result;
  },
};

function track(target, key) { 
  // 没有activeEffect,直接返回
  if (!activeEffect) {
    return;
  }
  // 1.根据target从buckets中获取depsMap,它是一个Map对象，保存类型是key---effects的键值对
  let depsMap = buckets.get(target);
  // 如果depsMap不存在,则创建一个新的Map对象
  if (!depsMap) {
    buckets.set(target, (depsMap = new Map()));
  }

  // 2.根据key从depsMap中获取effects,它是一个Set对象
  // 里面存储的是当前key对应的副作用函数
  let deps = depsMap.get(key);
  // 如果deps不存在,则创建一个新的Set对象
  if (!deps) {
    depsMap.set(key, (deps = new Set()));
  }

  // 3.将activeEffect存储到deps中
  deps.add(activeEffect);
}

function trigger(target, key) {
  // 根据target从buckets中获取depsMap
  const depsMap = buckets.get(target);
  // 如果depsMap不存在,则直接返回
  if (!depsMap) {
    return;
  }
  // 根据key从depsMap中获取effects
  const deps = depsMap.get(key);
  // 如果deps不存在,则直接返回
  if (!deps) {
    return;
  }
  // 执行effects中的副作用函数
  deps.forEach(fn => fn());
}

const proxy = new Proxy(obj, handler);

let activeEffect;

function effect(fn) {
  activeEffect = fn;
  fn();
}

effect(function effectFn() {
  console.log("fn");

  layer.innerHTML = proxy.name;
}); 

btn.addEventListener("click", () => {
  proxy.name = "李四"; // 触发更新

  // proxy.address = "北京"; 
});
```
